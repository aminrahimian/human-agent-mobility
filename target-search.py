import pandas as pdimport numpy as npimport pylab as plfrom scipy.stats import normimport itertoolsfrom scipy.spatial import distanceimport copyimport matplotlib.pyplot as pltimport multiprocessingfrom multiprocessing import Poolimport sysfrom itertools import productfrom scipy.stats import binomimport timeimport pickleimport networkx as nxfrom scipy.stats import bernoullifrom scipy.optimize import minimizefrom scipy.stats import multivariate_normalfrom scipy.stats import invwishart,wishartclass Enviroment:    def __init__(self,L):         self.L=L         self.phi=600         self.target_x=400         self.target_y=1870         self.target_found=False         self.epsilon = 100         n_x = int(np.ceil(self.L / (np.sqrt(2) * self.epsilon)))         n_y = int(np.ceil(self.L / (np.sqrt(2) * self.epsilon)))         nodes = np.arange(0, n_x * n_x).reshape((n_x, n_y))         G = nx.Graph()    def generate_binary_signal(self,x,y):         norm_dist=distance.euclidean((x,y),(self.target_x, self.target_y))         factor=(norm_dist/self.phi)**2         probability=np.exp(-factor)         sample= bernoulli.rvs(probability, size=1)[0]         return sample    def target_detected(self,x,y):         radial=distance.euclidean((self.target_x,self.target_y),(x,y))         print("dist from target :" +str(radial))         if radial<=self.epsilon:             print("-----------Target Found-------------------------!")             return True         else:             return Falseclass Agent:    def __init__(self,L,enviroment):        self.pos_x=0        self.pos_y=0        self.signals=[enviroment.generate_binary_signal(self.pos_x,        self.pos_y)]        self.time_step=0        self.path_x=[self.pos_x]        self.path_y=[self.pos_y]        self.phi=600        self.actions=[]        self.arc=np.pi/4        self.time_control=1        self.velocity=50        self.L=L        self.nx=200        self.ny=200        self.log_lik = np.zeros((self.nx, self.ny))        x = np.linspace(0, self.L, self.nx)        y = np.linspace(0, self.L, self.ny)        self.xv, self.yv = np.meshgrid(x, y)        self.mu_0=np.array([self.L*0.5+2, self.L*0.5+20])        self.Lambda_0=np.array([[600**2,0],        [0,600**2]])        self.theta_s=np.array([self.L*0.5+2, self.L*0.5+20])        self.Sigma_s=np.array([[(50)**2,0],        [0,(50)**2]])        self.Sigma_0=np.array([[(150)**2,0],        [0,(150)**2]])        self.nu_0=2        self.S_prop=np.array([[125**2,0],        [0,125**2]])    def likelihood(self,loc):        x=loc[0]        y=loc[1]        # np.repeat(3, 4)        signals = np.array(self.signals)        x_ref=np.repeat(x,self.time_step+1)        y_ref=np.repeat(y,self.time_step+1)        path_x = np.array(self.path_x)        path_y = np.array(self.path_y)        square_x=(path_x-x_ref)**2        square_y=(path_y-y_ref)**2        norm_2=(square_x+square_y)/(self.phi**2)        elle_1 = -norm_2        elle_0 = np.log(1- np.exp(-norm_2))        signal_1=elle_1*signals        bool_signal_1=np.array(signals,dtype=bool)        not_signals=np.logical_not(bool_signal_1)        not_signals=np.array(not_signals, dtype=int)        signal_0=elle_0*not_signals        return -1*np.sum(signal_1)+ (-1)*np.sum(signal_0)    def optimize_likelihood(self):        guess_x=self.L*np.random.uniform(0, 1)        guess_y=self.L*np.random.uniform(0, 1)        x0=[guess_x ,guess_y]        bnds = ((0, self.L), (0, self.L))        lik_model = minimize(self.likelihood, x0,bounds=bnds, method='trust-constr')        x_star=lik_model.x[0]        y_star=lik_model.x[1]        return (x_star, y_star)    def sampling_beta_star(self, beta_s):        beta_star = multivariate_normal.rvs(mean=beta_s, cov=self.S_prop, size=1)        return beta_star    def sampling_center_posterior(self,Betas,Sigma):        center_prior=np.array([self.L*0.5, self.L*0.5])        center_prior=center_prior.reshape((2,1))        Lambda_0=self.Lambda_0        m=len(self.signals)        Lambda_m=np.linalg.inv(np.linalg.inv(Lambda_0)+ m*np.linalg.inv(Sigma))        weighted_mu=np.matmul(np.linalg.inv(Lambda_0),center_prior)        beta_bar=np.mean(Betas, axis=1)        beta_bar=beta_bar.reshape((2,1))        compound_mean=np.add(weighted_mu ,m*np.matmul(np.linalg.inv(Sigma),beta_bar))        # print('beta bar: ' + str(beta_bar))        # print('weighted mu: ' + str(weighted_mu))        # print('Compound mean : ' +str(compound_mean))        mu_m=np.matmul(Lambda_m,compound_mean)        # print('center mean ' + str(mu_m))        # print('cov matrix' + str(Lambda_m))        mu_m=mu_m.reshape((2,))        center_sample=multivariate_normal.rvs(mean=mu_m, cov=Lambda_m, size=1)        return center_sample    def sampling_covariance_posterior(self, Theta, Betas):        S_theta=np.zeros((2,2))        Sigma_0=self.Sigma_0        for j in range(len(self.signals)):            diff_vector=Betas[:, j]-Theta            S_theta=S_theta+ np.matmul(diff_vector.reshape(2, 1), diff_vector.reshape(1, 2))        Sigma_total=Sigma_0+S_theta        m=len(self.signals)        Sigma_s=np.linalg.inv(wishart.rvs(df=m+self.nu_0, scale=np.linalg.inv(Sigma_total)))        # print('Theta, Betas, Sigma' +str((Theta, Betas,Sigma_s)))        # time.sleep(1)        return Sigma_s    def sampling_betas(self,signal_j,beta_j,beta_j_star,x,y,Theta, Sigma):        loc=np.array([x,y])        p1=np.exp(-(self.phi**(-2))*(loc-beta_j_star)@(loc-beta_j_star))        p2 = np.exp(-(self.phi ** (-2)) * (loc - beta_j) @ (loc - beta_j))        # print('Loc at the center/x/y : ' +str((beta_j,x,y)))        # print("radius square j " + str((loc - beta_j) @ (loc - beta_j)))        # print("factor exp " + str(-(self.phi**(-2))*(loc-beta_j_star)@(loc-beta_j_star)))        # print('pbeta / pbeta* ' +str((p2,p1)))        # print('========================================')        # time.sleep(1)        if signal_j==1:            log_r=np.log(p1) + np.log(multivariate_normal.pdf(x=beta_j_star, mean=Theta, cov=Sigma))- \            np.log(p2) - np.log(multivariate_normal.pdf(x=beta_j, mean=Theta, cov=Sigma))        else:            log_r = np.log(1-p1) + np.log(multivariate_normal.pdf(x=beta_j_star, mean=Theta, cov=Sigma)) - \            np.log(1-p2) - np.log(multivariate_normal.pdf(x=beta_j, mean=Theta, cov=Sigma))        log_u=np.log(np.random.uniform(0, 1))        # print("This is log r " +str(log_r) )        if log_u<log_r:            return (beta_j_star,1)        else:            return (beta_j,0)    def metropolis_hasting_theta(self):        Theta_0=self.theta_s        Sigma_s=self.Sigma_s        n=len(self.signals)        Betas=np.zeros((2,n))        ratio = np.zeros((1, n))        list_theta=[]        list_sigma=[]        list_betas=[]        cov_betas=np.array([[(100)**2,0],        [0,(100)**2]])        variance_x=[]        for i in range(n):            beta_j_0=multivariate_normal.rvs(mean=Theta_0, cov=cov_betas, size=1)            Betas[:,i]=beta_j_0            # print('Betas: ' + str(Betas))        for t in range(750):            theta_s = self.sampling_center_posterior(Betas, Sigma_s)            list_theta.append(theta_s)            Sigma_s = self.sampling_covariance_posterior(theta_s, Betas)            list_sigma.append(Sigma_s)            variance_x.append(Sigma_s[0,0])            for i in range(n):                signal_j=self.signals[i]                beta_j=Betas[:,i]                beta_j_star=self.sampling_beta_star(beta_j)                # print("beta s -- beta* " + str((beta_j, beta_j_star)))                # time.sleep(1)                x=self.path_x[i]                y=self.path_y[i]                info=(signal_j, beta_j, beta_j_star,x,y, theta_s, Sigma_s)                # print("to function: " +str(info))                Betas[:,i],cont=self.sampling_betas( signal_j, beta_j, beta_j_star, x, y, theta_s, Sigma_s)                ratio[0,i]+=cont        list_theta=np.array(list_theta)        map_theta=np.mean(list_theta,axis=0)        ratio=ratio/750        self.theta_s=map_theta        self.Sigma_s=Sigma_s        print('ratio ::   '  +str(ratio))        print('Media variance x ' +str(np.mean(variance_x)))        print('Quantiles :' + str((np.percentile(list_theta, 2.5,axis=0)[0],        np.percentile(list_theta, 50,axis=0)[0],        np.percentile(list_theta, 97.5, axis=0)[0])))        return (map_theta[0], map_theta[1])    def which_direction(self, local_opt):        comp_x = local_opt[0] - self.pos_x        comp_y = local_opt[1] - self.pos_y        radius = np.sqrt(comp_x ** 2 + comp_y ** 2)        angle = np.arctan2(comp_y, comp_x) / (np.pi * 0.25)        print("==============================")        print("local opt : " +str(local_opt))        print("position x y: " + str((self.pos_x, self.pos_y)))        # print("comp x y: " +str((comp_x, comp_x)))        # print("angle original: " + str(np.arctan2(comp_y, comp_x) ))        print("==============================")        return int(np.round(angle))    def one_step(self, enviroment):    # time.sleep(1)        local_opt=self.optimize_likelihood()        action=self.which_direction(local_opt)        # print("Take this actions " + str(action))        self.actions.append(action)        direction=action*np.pi*0.25        new_pos_x = self.pos_x + self.velocity * self.time_control * np.cos(direction)        new_pos_y = self.pos_y + self.velocity * self.time_control * np.sin(direction)        # print("Agent go to xy" + str((new_pos_x, new_pos_y)))        if new_pos_x > self.L:            new_pos_x = 2 * self.L - new_pos_x        if new_pos_x < 0:            new_pos_x = -1 * new_pos_x        if new_pos_y > self.L:            new_pos_y = 2 * self.L - new_pos_y        if new_pos_y < 0:            new_pos_y = -1 * new_pos_y        new_signal=enviroment.generate_binary_signal(new_pos_x, new_pos_y)        # print("got signal " + str(new_signal))        self.signals.append(new_signal)        self.pos_x=new_pos_x        self.pos_y=new_pos_y        self.path_x.append(new_pos_x)        self.path_y.append(new_pos_y)        self.time_step+=1    def one_step_logistic(self, enviroment):        # time.sleep(5)        x_map,y_map=self.metropolis_hasting_theta()        local_opt =(x_map, y_map)        action = self.which_direction(local_opt)        # print("Take this actions " + str(action))        self.actions.append(action)        direction = action * np.pi * 0.25        new_pos_x = self.pos_x + self.velocity * self.time_control * np.cos(direction)        new_pos_y = self.pos_y + self.velocity * self.time_control * np.sin(direction)        # print("Agent go to xy" + str((new_pos_x, new_pos_y)))        if new_pos_x > self.L:            new_pos_x = 2 * self.L - new_pos_x        if new_pos_x < 0:            new_pos_x = -1 * new_pos_x        if new_pos_y > self.L:            new_pos_y = 2 * self.L - new_pos_y        if new_pos_y < 0:            new_pos_y = -1 * new_pos_y        new_signal = enviroment.generate_binary_signal(new_pos_x, new_pos_y)        # print("got signal " + str(new_signal))        self.signals.append(new_signal)        self.pos_x = new_pos_x        self.pos_y = new_pos_y        self.path_x.append(new_pos_x)        self.path_y.append(new_pos_y)        self.time_step += 1    def search_task(self, enviroment):        # x_ref=self.pos_x        # y_ref=self.pos_y        while not enviroment.target_detected(self.pos_x, self.pos_y):            self.one_step(enviroment)            # print("hist signals " + str(self.signals))            if self.time_step > 20:                break            return self.time_step    def search_task_logit(self, enviroment):        while not enviroment.target_detected(self.pos_x, self.pos_y):            self.one_step_logistic(enviroment)            # print("hist signals " + str(self.signals))            if self.time_step > 200:                break        return self.time_stepL=2000e1=Enviroment(L)a1=Agent(L,e1)# sigma1=[]# pdf=[]## for i in range(500):## sampled=a1.sampling_Sigma_star(a1.Sigma_0)# # sampled_inv=np.linalg.inv(sampled)# sigma1.append(sampled[0,0])# pdf.append(wishart.pdf(x=sampled,df=3,scale=(a1.Sigma_0)))## #### pdf[0:5]## sigma1[0:5]## ## plt.hist(sigma1, bins=10)# # display histogram# plt.show()# ##a1.search_task_logit(e1)# a1.path_x# a1.path_y# a1.signals## a1.time_step## # plt.xlim([0, a1.L])# # plt.ylim([0, a1.L])#plt.plot(a1.path_x, a1.path_y, '--o', color='#65C7F5')pl.show()# vals_x=a1.metropolis_logistic_reg()[2]# plt.hist(vals_x, bins=50)## # display histogram# plt.show()## phi=1000