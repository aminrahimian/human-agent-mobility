import pandas as pdimport numpy as npimport pylab as plfrom scipy.stats import normimport itertoolsfrom scipy.spatial import distanceimport copyimport matplotlib.pyplot as pltimport multiprocessingfrom multiprocessing import Poolimport sysfrom itertools import productfrom scipy.stats import binomimport timeimport picklefrom scipy.stats import bernoullifrom scipy.optimize import minimizefrom scipy.stats import multivariate_normalfrom scipy.stats import invwishart,wishartimport mathclass Enviroment:    def __init__(self,L,target_location,phi):        self.target_location=target_location        self.L=L        self.phi=phi    def generate_binary_signal(self,x,y):         norm_dist=distance.euclidean((x,y),self.target_location)         probability=np.exp(-(norm_dist/self.phi)**2)         signal= bernoulli.rvs(probability, size=1)[0]         return signal    def target_detected(self,x,y):         radial=distance.euclidean(self.target_location,(x,y))         print("dist from target :" +str(radial))         if radial<=self.epsilon:             print("-----------Target Found-------------------------!")             return True         else:             return Falseclass Agent:    def __init__(self,enviroment,phi):        self.pos_x=1        self.pos_y=1        self.t=0        self.path_x=[self.pos_x]        self.path_y=[self.pos_y]        signal=enviroment.generate_binary_signal(self.pos_x, self.pos_y)        self.historical_data=[(self.pos_x, self.pos_y, signal)]        self.phi=phi        self.actions=[]        self.arc=np.pi/4        self.time_control=1        self.L=enviroment.L        self.nx=200        self.ny=200        self.log_lik = np.zeros((self.nx, self.ny))        x = np.linspace(0, self.L, self.nx)        y = np.linspace(0, self.L, self.ny)        self.xv, self.yv = np.meshgrid(x, y)        self.mu_0=np.array([self.L*0.5+2, self.L*0.5+20])        self.Lambda_0=np.array([[600**2,0],        [0,600**2]])        self.step_length=50        self.time_step=0        self.epsilon=100        self.theta_s=np.array([self.L*0.5+2, self.L*0.5+20])        self.Sigma_s=np.array([[(50)**2,0],        [0,(50)**2]])        self.Sigma_0=np.array([[(150)**2,0],        [0,(150)**2]])        self.nu_0=2        self.S_prop=np.array([[125**2,0],        [0,125**2]])    def likelihood_i(self, triplet_state_signal, target_opt):        norm_2=((distance.euclidean((triplet_state_signal[0],triplet_state_signal[1]),target_opt))**2)/(self.phi**2)        l=((triplet_state_signal[2])*(-1)*norm_2+           (1-triplet_state_signal[2])*np.log(1- np.exp(-norm_2)))        return -1*l    def likelihood(self, target_opt):        likelihoods=[self.likelihood_i(i,target_opt) for i in self.historical_data]        # print("Likelihoods: " + str(likelihoods) )        return np.sum(likelihoods)    def optimize_likelihood(self):        guess_x=self.L*np.random.uniform(0, 1)        guess_y=self.L*np.random.uniform(0, 1)        x0=[guess_x ,guess_y]        bnds = ((0, self.L), (0, self.L))        lik_model = minimize(self.likelihood, x0,bounds=bnds, method='trust-constr')        x_star=lik_model.x[0]        y_star=lik_model.x[1]        return (x_star, y_star)    def sampling_beta_star(self, beta_s):        beta_star = multivariate_normal.rvs(mean=beta_s, cov=self.S_prop, size=1)        return beta_star    def sampling_center_posterior(self,Betas,Sigma):        center_prior=np.array([self.L*0.5, self.L*0.5])        center_prior=center_prior.reshape((2,1))        Lambda_0=self.Lambda_0        m=len(self.signals)        Lambda_m=np.linalg.inv(np.linalg.inv(Lambda_0)+ m*np.linalg.inv(Sigma))        weighted_mu=np.matmul(np.linalg.inv(Lambda_0),center_prior)        beta_bar=np.mean(Betas, axis=1)        beta_bar=beta_bar.reshape((2,1))        compound_mean=np.add(weighted_mu ,m*np.matmul(np.linalg.inv(Sigma),beta_bar))        # print('beta bar: ' + str(beta_bar))        # print('weighted mu: ' + str(weighted_mu))        # print('Compound mean : ' +str(compound_mean))        mu_m=np.matmul(Lambda_m,compound_mean)        # print('center mean ' + str(mu_m))        # print('cov matrix' + str(Lambda_m))        mu_m=mu_m.reshape((2,))        center_sample=multivariate_normal.rvs(mean=mu_m, cov=Lambda_m, size=1)        return center_sample    def sampling_covariance_posterior(self, Theta, Betas):        S_theta=np.zeros((2,2))        Sigma_0=self.Sigma_0        for j in range(len(self.signals)):            diff_vector=Betas[:, j]-Theta            S_theta=S_theta+ np.matmul(diff_vector.reshape(2, 1), diff_vector.reshape(1, 2))        Sigma_total=Sigma_0+S_theta        m=len(self.signals)        Sigma_s=np.linalg.inv(wishart.rvs(df=m+self.nu_0, scale=np.linalg.inv(Sigma_total)))        # print('Theta, Betas, Sigma' +str((Theta, Betas,Sigma_s)))        # time.sleep(1)        return Sigma_s    def sampling_betas(self,signal_j,beta_j,beta_j_star,x,y,Theta, Sigma):        loc=np.array([x,y])        p1=np.exp(-(self.phi**(-2))*(loc-beta_j_star)@(loc-beta_j_star))        p2 = np.exp(-(self.phi ** (-2)) * (loc - beta_j) @ (loc - beta_j))        # print('Loc at the center/x/y : ' +str((beta_j,x,y)))        # print("radius square j " + str((loc - beta_j) @ (loc - beta_j)))        # print("factor exp " + str(-(self.phi**(-2))*(loc-beta_j_star)@(loc-beta_j_star)))        # print('pbeta / pbeta* ' +str((p2,p1)))        # print('========================================')        # time.sleep(1)        if signal_j==1:            log_r=np.log(p1) + np.log(multivariate_normal.pdf(x=beta_j_star, mean=Theta, cov=Sigma))- \            np.log(p2) - np.log(multivariate_normal.pdf(x=beta_j, mean=Theta, cov=Sigma))        else:            log_r = np.log(1-p1) + np.log(multivariate_normal.pdf(x=beta_j_star, mean=Theta, cov=Sigma)) - \            np.log(1-p2) - np.log(multivariate_normal.pdf(x=beta_j, mean=Theta, cov=Sigma))        log_u=np.log(np.random.uniform(0, 1))        # print("This is log r " +str(log_r) )        if log_u<log_r:            return (beta_j_star,1)        else:            return (beta_j,0)    def metropolis_hasting_theta(self):        Theta_0=self.theta_s        Sigma_s=self.Sigma_s        n=len(self.signals)        Betas=np.zeros((2,n))        ratio = np.zeros((1, n))        list_theta=[]        list_sigma=[]        list_betas=[]        cov_betas=np.array([[(100)**2,0],        [0,(100)**2]])        variance_x=[]        for i in range(n):            beta_j_0=multivariate_normal.rvs(mean=Theta_0, cov=cov_betas, size=1)            Betas[:,i]=beta_j_0            # print('Betas: ' + str(Betas))        for t in range(750):            theta_s = self.sampling_center_posterior(Betas, Sigma_s)            list_theta.append(theta_s)            Sigma_s = self.sampling_covariance_posterior(theta_s, Betas)            list_sigma.append(Sigma_s)            variance_x.append(Sigma_s[0,0])            for i in range(n):                signal_j=self.signals[i]                beta_j=Betas[:,i]                beta_j_star=self.sampling_beta_star(beta_j)                # print("beta s -- beta* " + str((beta_j, beta_j_star)))                # time.sleep(1)                x=self.path_x[i]                y=self.path_y[i]                info=(signal_j, beta_j, beta_j_star,x,y, theta_s, Sigma_s)                # print("to function: " +str(info))                Betas[:,i],cont=self.sampling_betas( signal_j, beta_j, beta_j_star, x, y, theta_s, Sigma_s)                ratio[0,i]+=cont        list_theta=np.array(list_theta)        map_theta=np.mean(list_theta,axis=0)        ratio=ratio/750        self.theta_s=map_theta        self.Sigma_s=Sigma_s        # print('ratio ::   '  +str(ratio))        # print('Media variance x ' +str(np.mean(variance_x)))        # print('Radius x :' + str((-np.percentile(list_theta, 2.5,axis=0)[0]+\        #                           np.percentile(list_theta, 97.5, axis=0)[0])))        # np.percentile(list_theta, 50, axis=0)[0],        return (map_theta[0], map_theta[1])    def direction(self, target_opt,pos_x,pos_y):        delta_x = target_opt[0] - pos_x        delta_y = target_opt[1] - pos_y        angle= math.atan2(delta_y, delta_x)        int_angle=np.round(angle/(np.pi * 0.25))*np.pi * 0.25        print("angle original: " + str(angle ))        print("modified angle:  " + str(int_angle))        # print("==============================")        # print("local opt : " +str(local_opt))        # print("position x y: " + str(m(self.pos_x, self.pos_y)))        # print("comp x y: " +str((comp_x, comp_x)))        # print("angle original: " + str(np.arctan2(comp_y, comp_x) ))        print("==============================")        return int_angle    def next_location(self, pos_x,pos_y, direction):        # print("Take this actions " + str(action))        new_pos_x = pos_x + np.cos(direction)*self.step_length        new_pos_y = pos_y + np.sin(direction)*self.step_length        # print("Agent go to xy" + str((new_pos_x, new_pos_y)))        if new_pos_x > self.L:            new_pos_x = 2 * self.L - new_pos_x        if new_pos_x < 0:            new_pos_x = -1 * new_pos_x        if new_pos_y > self.L:            new_pos_y = 2 * self.L - new_pos_y        if new_pos_y < 0:            new_pos_y = -1 * new_pos_y        # print("got signal " + str(new_signal))        return (new_pos_x, new_pos_y)    def update_agent(self, pos_x_prime, pos_y_prime, signal):        self.pos_x=pos_x_prime        self.pos_y=pos_y_prime        self.path_x.append(pos_x_prime)        self.path_y.append(pos_y_prime)        self.historical_data.append((pos_x_prime, pos_y_prime, signal))        self.time_step+=1    def one_step_logistic(self, enviroment):        # time.sleep(5)        x_map,y_map=self.metropolis_hasting_theta()        local_opt =(x_map, y_map)        action = self.which_direction(local_opt)        # print("Take this actions " + str(action))        self.actions.append(action)        direction = action * np.pi * 0.25        new_pos_x = self.pos_x + self.velocity * self.time_control * np.cos(direction)        new_pos_y = self.pos_y + self.velocity * self.time_control * np.sin(direction)        # print("Agent go to xy" + str((new_pos_x, new_pos_y)))        if new_pos_x > self.L:            new_pos_x = 2 * self.L - new_pos_x        if new_pos_x < 0:            new_pos_x = -1 * new_pos_x        if new_pos_y > self.L:            new_pos_y = 2 * self.L - new_pos_y        if new_pos_y < 0:            new_pos_y = -1 * new_pos_y        new_signal = enviroment.generate_binary_signal(new_pos_x, new_pos_y)        # print("got signal " + str(new_signal))        self.signals.append(new_signal)        self.pos_x = new_pos_x        self.pos_y = new_pos_y        self.path_x.append(new_pos_x)        self.path_y.append(new_pos_y)        self.time_step += 1    def search_task(self, enviroment):        # x_ref=self.pos_x        # y_ref=self.pos_y        while not enviroment.target_detected(self.pos_x, self.pos_y):            self.one_step(enviroment)            # print("hist signals " + str(self.signals))            if self.time_step > 20:                break            return self.time_step    def search_task_logit(self, enviroment):        while not enviroment.target_detected(self.pos_x, self.pos_y):            self.one_step_logistic(enviroment)            # print("hist signals " + str(self.signals))            if self.time_step > 200:                break        return self.time_step    def pure_exploitation(self, enviroment):        target_location = enviroment.target_location        to_target = distance.euclidean((a1.pos_x, a1.pos_y), target_location)        while to_target > self.epsilon:            pos_x = self.pos_x            pos_y = self.pos_y            target_opt = self.optimize_likelihood()            print("From " + str((pos_x, pos_y)) + "to " + str(target_opt))            direction = self.direction(target_opt, pos_x, pos_y)            pos_x_prime, pos_y_prime = self.next_location(pos_x, pos_y, direction)            signal = e1.generate_binary_signal(pos_x_prime, pos_y_prime)            self.update_agent(pos_x_prime, pos_y_prime, signal)            to_target = distance.euclidean((pos_x, pos_y), target_location)            print("Away from target" + str(to_target))            time.sleep(0)if __name__ == "__main__":    target_location=(670,1400)    L=2000    phi=500    e1=Enviroment(L,target_location,phi)    a1=Agent(e1,phi)    to_target = distance.euclidean((a1.pos_x, a1.pos_y), target_location)    while to_target>a1.epsilon:        pos_x=a1.pos_x        pos_y=a1.pos_y        target_opt=a1.optimize_likelihood()        print("From " +str((pos_x, pos_y))  + "to " + str(target_opt))        direction=a1.direction(target_opt, pos_x, pos_y)        pos_x_prime, pos_y_prime=a1.next_location(pos_x, pos_y, direction)        signal=e1.generate_binary_signal(pos_x_prime, pos_y_prime)        a1.update_agent(pos_x_prime, pos_y_prime, signal)        to_target = distance.euclidean((pos_x, pos_y), target_location)        print("Away from target" + str(to_target))        time.sleep(0)    a1.historical_data    # a1.search_task_logit(e1)    #    #    # plt.plot(a1.path_x, a1.path_y, '--o', color='#65C7F5')    # pl.show()